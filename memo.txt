~mongoose설치까지
##6.9시작하기 
+upload +id +see+ edit +Delete 등등
+user auth진행하기

req.body를 위해서는 urlencoded가 필요함을 깜빡함..
>해놧는데 이상...
    this.$__.validationError = new ValidationError(this);
                               ^

ValidationError: Video validation failed: title: Path `title` is required., summary: Path `summary` is required.
    at model.Document.invalidate (/home/hyeonhee/wetube_final/node_modules/mongoose/lib/document.js:3081:32)
    at /home/hyeonhee/wetube_final/node_modules/mongoose/lib/document.js:2869:17
    at /home/hyeonhee/wetube_final/node_modules/mongoose/lib/schematype.js:1350:9
    at processTicksAndRejections (node:internal/process/task_queues:77:11) {
  errors: {
    title: ValidatorError: Path `title` is required.
        at validate (/home/hyeonhee/wetube_final/node_modules/mongoose/lib/schematype.js:1347:13)
        at SchemaString.SchemaType.doValidate (/home/hyeonhee/wetube_final/node_modules/mongoose/lib/schematype.js:1331:7)
        at /home/hyeonhee/wetube_final/node_modules/mongoose/lib/document.js:2861:18
        at processTicksAndRejections (node:internal/process/task_queues:77:11) {
      properties: {
        validator: [Function (anonymous)],
        message: 'Path `title` is required.',
        type: 'required',
        path: 'title',
        value: undefined
      },
      kind: 'required',
      path: 'title',
      value: undefined,
      reason: undefined,
      [Symbol(mongoose:validatorError)]: true
    },
    summary: ValidatorError: Path `summary` is required.
    이런 에러가 자꾸 뜸.

>createdAt 에서 오바해서 그런가 
>계속 mongoose 가 동작을 안해서(req.params, req.body 모두 빈 object로 나옴) 코드를 따라가보니 
init.js에서 

import Video from "./models/Video";
import User from "./models/User"; 

이렇게 되어있음을 확인했다. 

import "./models/Video";
import "./models/User";
이렇게 넣어줘야한다 (이유를 잘 모르겠음..)

> req.body 가 {} 지속되어서 에러가 난다. 
express.json()까지 app.use중인데도 해소가 안됨 
>하지만 최신버전에서는 express가 body-parser를 포함하고 있기 때문에 별도로 bodyparser는 require를 할 필요가 없다고 한다

const videoSchema = new mongoose.Schema
>new빼먹음.. 

> req.body {} 의 이유는 ,enctype="multipart/form-data" 설정을
form에 미리해둔것 때문임이 밝혀졌다. 기본기의 중요성..


sort()문법 까먹음 

sort({createdAt:"desc"}) 임 

new Date로 시간 달..이런식으로 분류해보려고 했으나 실패 
new Date() 이렇게 괄호로 당장 실행하는 기능때문에 파일이 저장되는 순간의
시간이 떠서, 실 시간이랑 괴리가 있다. 

정규식 어려웠지만 regex101에 연습하면서 익혔음 
try and catch 연습

화살표 &rarr; 인데 또 까먹었다..&잊음

계속 url을 
videoRouter.route("/:id([0-9a-f]{24})/edit") 이걸 
상대경로를 통해서 edit만 추가해서 구현하려고 애썼다..

stringStartwith기억안났음...검색해서 찾았다 

자바스크립트 콘솔에서는 너무 잘 되는데 edit 컨트롤러에서 안먹힘

apple.toString().split(",")
(4) ['1', '2', '3', '4']
apple.toString().split(",").map((x)=> x.startsWith("#")? x : "#"+x)
(4) ['#1', '#2', '#3', '#4']
const banana=["#2",1,2,3,"#a"]
undefined
banana.toString().split(",").map((x)=> x.startsWith("#")? x : "#"+x)
(5) ['#2', '#1', '#2', '#3', '#a']

이유 =-> join 함수를 제대로 쓸줄 몰랐기 때문이었다. 
edit form 의 hashtag value에 join() 이 포함된 값을 넣어야했음 

findbyID로 해줄필요 없을때(object 안쓸때)는 exist로 validation 판단하기


this.hashtags부분이 어색했다. middleware로 만들어 사용하는 부분 

middleware로 hash를 뺀 이후에 update가 잘 동작하지 않았다(#안만들어줌)
findByIdAndUpdate는 save를 호출하지 않는걸 간과함. 


video.sth을 만듦 => static
https://mongoosejs.com/docs/guide.html#statics
https://mongoosejs.com/docs/2.7.x/docs/methods-statics.html

static 만드는 문법 어색했다. 이름을 제대로 붙여주지 않아서("" 없어서) 에러도 발생했었음


remove보다 delete 사용을 권장함 (롤백가능한 옵션)

search page 단순 레더링후 req.qeury까지만 확인
hashtag나 genre로도 솔팅하는 기능 넣으면 좋을듯(장르별 페이지를 따로 제공하거나)

>>03.06

findone을썼더니 id를 못찾겠다고 오류가 계속 났다 
findone을 썼을때 => 
{
  _id: new ObjectId("64051b50f1842e905820032a"),
  title: 'a',
  summary: 'abcdef',
  hashtags: [ '#fun', '#fantastic', '#thrill' ],
  genres: [ 't', 'h', 'y', 'j' ],
  views: '0',
  createdDate: 2023-03-05T22:44:32.030Z,
  __v: 0
}

find 를 썼을때 =>
[
  {
    _id: new ObjectId("64051b50f1842e905820032a"),
    title: 'a',
    summary: 'abcdef',
    hashtags: [ '#fun', '#fantastic', '#thrill' ],
    genres: [ 't', 'h', 'y', 'j' ],
    views: '0',
    createdDate: 2023-03-05T22:44:32.030Z,
    __v: 0
  }
]
애초에 findOne은 array반환을 못해줘서 그렇다는 사실을 알게됨 

hash랑 genres를 지웠을땐 구현이 되는데 만들면 구현이 안되고
첫째 조건문을 넘지못하는 듯 하다 
별개로 hashtag나 genres는 filter을 써봐야하나 생각 중 
하고 comment쪽 구현하기 (~8강 + 15~16강)

내가 array의 필터같은 이상한 기능으로 구현해보려고 한것은 
 $regex : new RegExp('$title',)
 이런 간단한 정규식으로 가능했다. 
 즉 string에서 포함하는 것 골라내기 의 개념이었던 것이다 

 제대로된 공식문서를 봐야한다. 쓸수있는 flag가 한정되어있는걸 모르고 계속
 [] 를 시도했따. 포함되는 문자열을 찾고싶어서 
 https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/RegExp/RegExp

 in이라는 query까지 찾았으나 결국 포기 
 시간아깝다...


 user db 에는 저장이 되는데 , redirect  가 안되고 있음 
=> login 페이지랑 컨트롤러를 아예안만들었으니 당연했다..


bcrypt쓰는게 너무 어색했다. 
pre,save 문법을 먼 저 쓴 후에 bcrypt문서를 참조해서 함수를 쓰는게 나았다. 
err,hash를 괜히 넣으려고 했음 

 userSchema.pre("save", async function () {
  this.password = await bcrypt.hash(this.password, 5);
});


Parameter "filter" to findOne() must be an object,
메소드는 오브젝트가 필수이거늘..


compare 함수를 잘 못쓰겠다...
  bcrypt.compare(password, user.password, function (err, validation) {
    return validation;
  });
  if (!validation) {
    const errorMessage = "Password doesn't match with Username";
    return res.status(404).render("user/login", { errorMessage });
  }

  안돌아감 

const validation = bcrypt.compare(password, user.password);
이게 끝이었다. 황당...
문서를 잘 보는 연습을 해보자 
https://www.npmjs.com/package/bcrypt

여전히 계속 true 같이 나와서 확인해보니 
await 가 없었다.
힌트는 console.log(validation)을 했을때 Promise { <pending> }
이렇게 나온 부분이었다.
즉 아직 pending 중이니, await를 이용해서 작업이 다 끝나기를 기다려
줘야했고, await를 써줘야했던것이다. 


express-session에 있는 환경설정 코드를 그대로 보고 썼더니 쿠키가 안보여서 당황함
app.use(
  session({
    secret: "topsecret",
    resave: false,
    saveUninitialized: true,
    cookie: { secure: true },
  })
);
cookie: { secure: true }
 즉 쿠키가 secure 처리되어서 안보였던것! 

+resave는 true 설정

app.use((req, res, next) => {
  console.log(req.headers);
  next();
});
이렇게 헤더를 확인하거나 req만 써서 확인해볼것 
나는 req.session으로만 봐서 더 많은 정보를 보기 어려웠다 

res.locals 개념을 헷갈렸다. 그래서 유저의 정보를 저장하는데 애를 먹었음
res.locals에 떡하니 유저인증에 쓰라고 써있다
This property is useful for exposing request-level information such as the request path name, authenticated user, user settings, 
and so on to templates rendered within the application. 



  $or: [{ username }, { email }] 
  난 요걸 안쓰고 구현했다(join페이지에 기존유저 있는지 확인하는 부분에서 email을 넣지않았는데..넣어야겠다)

  join 페이지에 있는 status 코드를 400으로 바꿔줌. 없는 데이터가 아니라 그런듯 


  res.locals.loggedIn = req.session.loggedIn;
  이렇게 두면 undefined나옴
  Boolean으로 감싸서 type 을 확인해줘야한다 

      if !loggedIn
      li 
        a(href="/join") Join
      li 
        a(href="/login") Login

이게 아니고 if else로 구현할것 